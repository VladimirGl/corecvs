<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DeepView: core/geometry/triangulation.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DeepView
   &#160;<span id="projectnumber">0.02</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">core/geometry/triangulation.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="triangulation_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> * \file triangulation.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> * \brief Add Comment Here</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * \ingroup cppcorefiles</span>
<a name="l00006"></a>00006 <span class="comment"> * \date Nov 12, 2010</span>
<a name="l00007"></a>00007 <span class="comment"> * \author eseppel</span>
<a name="l00008"></a>00008 <span class="comment"> * \author alexander</span>
<a name="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="preciseTimer_8h.html" title="Add Comment Here.">preciseTimer.h</a>&quot;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="triangulation_8h.html" title="Add Comment Here.">triangulation.h</a>&quot;</span>
<a name="l00015"></a><a class="code" href="namespaceTriangulation.html">00015</a> <span class="keyword">namespace </span>Triangulation
<a name="l00016"></a>00016 {
<a name="l00017"></a>00017 
<a name="l00018"></a><a class="code" href="namespaceTriangulation.html#a0efabaf278bfbb4770d073801d480667">00018</a> <span class="keywordtype">int</span> <a class="code" href="namespaceTriangulation.html#a0efabaf278bfbb4770d073801d480667">orientation</a> (<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p0, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p1, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p2)
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020     <a class="code" href="classTriangulation_1_1Point.html">Point</a> a = p1  - p0;
<a name="l00021"></a>00021     <a class="code" href="classTriangulation_1_1Point.html">Point</a> b = p2  - p0;
<a name="l00022"></a>00022 
<a name="l00023"></a>00023     <span class="comment">//double sa = a.x() * b.y() - b.x() * a.y();</span>
<a name="l00024"></a>00024   <span class="keywordtype">double</span> sa = a.<a class="code" href="classcorecvs_1_1Vector2d.html#acd129e3172924eca8f3b1354453ff863">triangleOrientedAreaTo</a>(b);
<a name="l00025"></a>00025 
<a name="l00026"></a>00026     <span class="keywordflow">if</span> (sa &gt; 0.0)
<a name="l00027"></a>00027         <span class="keywordflow">return</span> 1;
<a name="l00028"></a>00028     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sa &lt; 0.0)
<a name="l00029"></a>00029         <span class="keywordflow">return</span> -1;
<a name="l00030"></a>00030     <span class="keywordflow">return</span> 0;
<a name="l00031"></a>00031 }
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="classTriangulation_1_1Edge.html#aa51ad578e520456695eb0afa20ccb3a9">00033</a> <span class="keyword">inline</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;<a class="code" href="classTriangulation_1_1Edge.html#aa51ad578e520456695eb0afa20ccb3a9">Edge::flip</a>(<span class="keywordtype">void</span>)
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035   <a class="code" href="classTriangulation_1_1Point.html">Point</a> tmp = <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00036"></a>00036     <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a> = <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>;
<a name="l00037"></a>00037     <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> = tmp;
<a name="l00038"></a>00038     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="classTriangulation_1_1Edge.html#a476c5c9e339171589165e148f6ff8929">00041</a> <span class="keyword">inline</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> <a class="code" href="classTriangulation_1_1Edge.html#a476c5c9e339171589165e148f6ff8929">Edge::point</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> t)<span class="keyword"> const</span>
<a name="l00042"></a>00042 <span class="keyword"></span>{
<a name="l00043"></a>00043     <span class="keywordflow">return</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a>(<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a> + t * (<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> - <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>));
<a name="l00044"></a>00044 }
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">/**</span>
<a name="l00047"></a>00047 <span class="comment"> * Having the edge rotated 90deg around the center</span>
<a name="l00048"></a>00048 <span class="comment"> **/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="classTriangulation_1_1Edge.html#ae3343789172457cb14ddbfed53864658">00050</a> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;<a class="code" href="classTriangulation_1_1Edge.html#ae3343789172457cb14ddbfed53864658" title="Having the edge rotated 90deg around the center.">Edge::rot</a>(<span class="keywordtype">void</span>)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052     <a class="code" href="classTriangulation_1_1Point.html">Point</a> m = 0.5 * (<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a> + <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>);
<a name="l00053"></a>00053     <a class="code" href="classTriangulation_1_1Point.html">Point</a> v = <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> - <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00054"></a>00054     <a class="code" href="classTriangulation_1_1Point.html">Point</a> n(v.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>(), -v.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>());
<a name="l00055"></a>00055     <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> = m - 0.5 * n;
<a name="l00056"></a>00056     org = m + 0.5 * n;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">/** comparison precise up to epsilon</span>
<a name="l00062"></a>00062 <span class="comment"> *</span>
<a name="l00063"></a>00063 <span class="comment"> *</span>
<a name="l00064"></a>00064 <span class="comment"> */</span>
<a name="l00065"></a><a class="code" href="namespaceTriangulation.html#a7a00d0364de4be64bf16fcf9452d31d2">00065</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceTriangulation.html#a7a00d0364de4be64bf16fcf9452d31d2" title="comparison precise up to epsilon">doubleEqual</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> a, <span class="keyword">const</span> <span class="keywordtype">double</span> b)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067     <span class="keywordflow">return</span> (fabs(a-b) &lt; <a class="code" href="namespaceTriangulation.html#afa0cc00702ac5ec0a1a149038e77e24f">EPSILON</a>);
<a name="l00068"></a>00068 }
<a name="l00069"></a>00069 
<a name="l00070"></a><a class="code" href="classTriangulation_1_1Edge.html#ab4563d6b741e983ef600d340595f3cfc">00070</a> <span class="keywordtype">int</span> <a class="code" href="classTriangulation_1_1Edge.html#ab4563d6b741e983ef600d340595f3cfc">Edge::intersect</a>(<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e, <span class="keywordtype">double</span> &amp;t)<span class="keyword"> const</span>
<a name="l00071"></a>00071 <span class="keyword"></span>{
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     <a class="code" href="classTriangulation_1_1Point.html">Point</a> c = e.<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00074"></a>00074     <a class="code" href="classTriangulation_1_1Point.html">Point</a> d = e.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     <a class="code" href="classcorecvs_1_1Vector2d.html">Vector2dd</a> n = ((<a class="code" href="namespacecorecvs.html#af76dfccc4f8b3f0a802cc2dd27a3b303">Vector2dd</a>)(d - c)).rightNormal();
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="keywordtype">double</span> denom = n &amp; (<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> - <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>);
<a name="l00079"></a>00079 
<a name="l00080"></a>00080     <span class="keywordflow">if</span> (<span class="comment">/*denom == 0*/</span> <a class="code" href="namespaceTriangulation.html#a7a00d0364de4be64bf16fcf9452d31d2" title="comparison precise up to epsilon">doubleEqual</a>(denom, 0.0))
<a name="l00081"></a>00081     {
<a name="l00082"></a>00082         <span class="keywordtype">int</span> aclass = e.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>);
<a name="l00083"></a>00083         <span class="keywordflow">if</span> ((aclass == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9" title="Point is to the left of the edge.">LEFT</a>) || (aclass == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a>))
<a name="l00084"></a>00084             <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3daf513e755b8a314976060dd1bbb322bde">PARALLEL</a>;
<a name="l00085"></a>00085         <span class="keywordflow">else</span>
<a name="l00086"></a>00086             <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da721113e201ab78b3738e0213968c0ed3">COLLINEAR</a>;
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088     <span class="keywordtype">double</span> num = n &amp; (<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a> - c);
<a name="l00089"></a>00089     t = -num / denom;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04">SKEW</a>;
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="classTriangulation_1_1Edge.html#a730bfe3d681de1b86180b19deb1676a8">00094</a> <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="classTriangulation_1_1Edge.html#a730bfe3d681de1b86180b19deb1676a8">Edge::cosAngle</a>(<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e2)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096     <a class="code" href="classTriangulation_1_1Point.html">Point</a> p0 = <a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> - <a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00097"></a>00097     <a class="code" href="classTriangulation_1_1Point.html">Point</a> p1 = e2.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> - e2.<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00098"></a>00098     <span class="keywordflow">return</span> p0.<a class="code" href="classcorecvs_1_1Vector2d.html#a393c79aff6e42d8d3c2238e031f720f2">cosineTo</a>(p1);
<a name="l00099"></a>00099 }
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">00101</a> <span class="keywordtype">int</span> <a class="code" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">classify</a>(<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;dest, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;org, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p2)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103     <a class="code" href="classTriangulation_1_1Point.html">Point</a> a = dest - org;
<a name="l00104"></a>00104     <a class="code" href="classTriangulation_1_1Point.html">Point</a> b = p2 - org;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     <span class="keywordtype">double</span> sa = a.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>() * b.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>() - b.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>() * a.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>();
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="keywordflow">if</span> (sa &gt; 0.0)
<a name="l00109"></a>00109         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a>;
<a name="l00110"></a>00110     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sa &lt; 0.0)
<a name="l00111"></a>00111         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9" title="Point is to the left of the edge.">LEFT</a>;
<a name="l00112"></a>00112     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((a.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>() * b.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>() &lt; 0.0) || (a.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>() * b.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>() &lt; 0.0))
<a name="l00113"></a>00113         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7" title="Point is on the same line as the edge but before the start.">BEHIND</a>;
<a name="l00114"></a>00114     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a.<a class="code" href="classTriangulation_1_1Point.html#ac51a33cef7462faf25a03a5f8eaa127c">length</a>() &lt; b.<a class="code" href="classTriangulation_1_1Point.html#ac51a33cef7462faf25a03a5f8eaa127c">length</a>())
<a name="l00115"></a>00115         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b" title="Point is on the same line as the edge but beyond the end.">BEYOND</a>;
<a name="l00116"></a>00116     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (org == p2)
<a name="l00117"></a>00117         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>;
<a name="l00118"></a>00118     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dest == p2)
<a name="l00119"></a>00119         <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760" title="The point is the destination.">DESTINATION</a>;
<a name="l00120"></a>00120     <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a>;
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">/**</span>
<a name="l00124"></a>00124 <span class="comment"> * Searches for the the closest point on the right of the edge.</span>
<a name="l00125"></a>00125 <span class="comment"> * Condition is that the circle around given 3 points should not contain other points</span>
<a name="l00126"></a>00126 <span class="comment"> *</span>
<a name="l00127"></a>00127 <span class="comment"> * */</span>
<a name="l00128"></a><a class="code" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968">00128</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968" title="Searches for the the closest point on the right of the edge.">mate</a> (<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e, <span class="keyword">const</span> vector&lt;Point&gt; &amp;points, <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130     <a class="code" href="classTriangulation_1_1Point.html">Point</a> bestp(0,0);
<a name="l00131"></a>00131         <span class="keywordtype">double</span> t, bestt = std::numeric_limits&lt;double&gt;::max();
<a name="l00132"></a>00132     <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> f = e;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     f.<a class="code" href="classTriangulation_1_1Edge.html#ae3343789172457cb14ddbfed53864658" title="Having the edge rotated 90deg around the center.">rot</a>();      <span class="comment">// f - perpendicular to the center of the segment ะต</span>
<a name="l00135"></a>00135     <span class="comment">//cout &lt;&lt; &quot;enum {LEFT = 0,  RIGHT = 1,  BEYOND = 2,  BEHIND = 3, BETWEEN = 4, ORIGIN = 5, DESTINATION = 6};\n&quot;;</span>
<a name="l00136"></a>00136     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); i++)
<a name="l00137"></a>00137     {
<a name="l00138"></a>00138         <span class="comment">//cout &lt;&lt; &quot;    Classify: &quot; &lt;&lt; points[i] &lt;&lt; &quot; for &quot; &lt;&lt; e &lt;&lt; &quot; is: &quot; &lt;&lt; e.classify(points[i]) &lt;&lt; endl;</span>
<a name="l00139"></a>00139         <span class="keywordflow">if</span> (e.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(points[i]) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a>)
<a name="l00140"></a>00140         {
<a name="l00141"></a>00141             <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> g(e.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>, points[i]);
<a name="l00142"></a>00142             g.<a class="code" href="classTriangulation_1_1Edge.html#ae3343789172457cb14ddbfed53864658" title="Having the edge rotated 90deg around the center.">rot</a>();
<a name="l00143"></a>00143             <span class="keywordtype">int</span> intersect = f.<a class="code" href="classTriangulation_1_1Edge.html#ab4563d6b741e983ef600d340595f3cfc">intersect</a> (g, t);
<a name="l00144"></a>00144             <span class="comment">//cout &lt;&lt; &quot;        enum {COLLINEAR = 0, PARALLEL = 1, SKEW = 2, SKEW_CROSS = 3, SKEW_NO_CROSS = 4 }\n &quot;;</span>
<a name="l00145"></a>00145             <span class="comment">//cout        &lt;&lt; &quot;intersecting: &quot; &lt;&lt; f &lt;&lt; &quot; and &quot; &lt;&lt; g &lt;&lt; &quot;. intersect = : &quot; &lt;&lt; intersect &lt;&lt; &quot;, t = &quot; &lt;&lt; t &lt;&lt; endl;</span>
<a name="l00146"></a>00146             <span class="keywordflow">if</span> (t &lt; bestt &amp;&amp; intersect == <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04">SKEW</a> )
<a name="l00147"></a>00147             {
<a name="l00148"></a>00148                 bestp = points[i];
<a name="l00149"></a>00149                 bestt = t;
<a name="l00150"></a>00150             }
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="keywordflow">if</span> ((bestp.<a class="code" href="classcorecvs_1_1Vector2d.html#a944721c41f044c1388d9dc42ca899bce">x</a>() != 0) &amp;&amp; (bestp.<a class="code" href="classcorecvs_1_1Vector2d.html#ae1ea2ad4c0821001408bf963cffa8413">y</a>() != 0))
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156         p = bestp;
<a name="l00157"></a>00157         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">// search of the &quot;minimum edge&quot; - the first edge for triangulation</span>
<a name="l00164"></a><a class="code" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">00164</a> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> <a class="code" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">hullEdge</a> (<span class="keyword">const</span> vector&lt;Point&gt; &amp;points)
<a name="l00165"></a>00165 {
<a name="l00166"></a>00166     <span class="keywordtype">size_t</span> m = 0;
<a name="l00167"></a>00167     <span class="keywordtype">size_t</span> i;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="keywordflow">for</span> (i = 1; i &lt; points.size(); i++)
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171         <span class="keywordflow">if</span> (points[i] &lt; points[m])
<a name="l00172"></a>00172             m = i;
<a name="l00173"></a>00173     }
<a name="l00174"></a>00174     <span class="keywordtype">size_t</span> min = m; <span class="comment">// &quot;minimal point&quot;</span>
<a name="l00175"></a>00175     m = 0;
<a name="l00176"></a>00176     i = 1;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="comment">// processing the marginal situations, when &quot;minimal point&quot; is one of the first ones</span>
<a name="l00179"></a>00179     <span class="keywordflow">if</span> (min == 0)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181         m = 1;
<a name="l00182"></a>00182         i = 2;
<a name="l00183"></a>00183     }
<a name="l00184"></a>00184     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (min == 1)
<a name="l00185"></a>00185         i = 2;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="comment">// serching for the seconf point of the &quot;minimum edge&quot;</span>
<a name="l00188"></a>00188     <span class="keywordflow">for</span> (; i &lt; points.size(); i++)
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190         <span class="keywordflow">if</span> (i == min)
<a name="l00191"></a>00191             <span class="keywordflow">continue</span>;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         <span class="keywordtype">int</span> c = <a class="code" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">classify</a>(points[min], points[m], points[i]);
<a name="l00194"></a>00194         <span class="keywordflow">if</span> (c  ==  <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || c  == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a>)
<a name="l00195"></a>00195             m = i;
<a name="l00196"></a>00196     }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="keywordflow">return</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a>(points[min], points[m]);
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">// updating the &quot;hull&quot;</span>
<a name="l00202"></a>00202 <span class="comment">// in attempt to add &quot;dead&quot; point, returns 1</span>
<a name="l00203"></a><a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">00203</a> <span class="keywordtype">int</span> <a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a>(set&lt;Edge,    EdgeCmp&gt; &amp;frontier, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;b, set&lt;Edge,    EdgeCmp&gt; &amp;died)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205 <span class="preprocessor">#if !defined(_MSC_VER) || (_MSC_VER &gt; 1500)         // TODO: VS2008 doesn&#39;t compile this code!?</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>    <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> e(a,b);
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (frontier.find(e) != frontier.end())
<a name="l00208"></a>00208     {
<a name="l00209"></a>00209         <span class="comment">//cout &lt;&lt; &quot;[updateFrontier] erasing &quot; &lt;&lt; e &lt;&lt; &quot;from frontier\n&quot;;</span>
<a name="l00210"></a>00210         frontier.erase(e);
<a name="l00211"></a>00211         died.insert(e);
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     <span class="keywordflow">else</span>
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215         e.<a class="code" href="classTriangulation_1_1Edge.html#aa51ad578e520456695eb0afa20ccb3a9">flip</a>();
<a name="l00216"></a>00216         <span class="keywordflow">if</span> (died.find(e) == died.end())
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218             <span class="comment">//cout &lt;&lt; &quot;[updateFrontier] inserting &quot; &lt;&lt; e &lt;&lt; &quot; with length: &quot; &lt;&lt; e.org.remoteness(e.dest)&lt;&lt; &quot; to frontier\n&quot;;</span>
<a name="l00219"></a>00219             frontier.insert(e);
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221         <span class="keywordflow">else</span>
<a name="l00222"></a>00222             <span class="keywordflow">return</span> 1;
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 <span class="preprocessor">#endif</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="namespaceTriangulation.html#ab38d7ad94fc43883068b0df2550efa94">00228</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceTriangulation.html#ab38d7ad94fc43883068b0df2550efa94">isInsideTriangle</a>(<span class="comment">/*const vector&lt;Point&gt; &amp;triangle*/</span>
<a name="l00229"></a>00229         <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e1, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e2, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e3, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;point)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231     <span class="comment">//RIGHT BETWEEN ORIGIN DESTINATION</span>
<a name="l00232"></a>00232     <span class="keywordflow">if</span> ( (e1.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e1.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e1.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>) &amp;&amp;
<a name="l00233"></a>00233              (e2.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e2.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e2.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>) &amp;&amp;
<a name="l00234"></a>00234              (e3.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e3.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e3.<a class="code" href="classTriangulation_1_1Edge.html#a5298d42797c519d6b1a25e9f89a7a218">classify</a>(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>))
<a name="l00235"></a>00235         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00236"></a>00236     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a><a class="code" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">00239</a> <a class="code" href="classTriangulation_1_1Point.html">Point</a> <a class="code" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">findTriangleCenter</a>(<span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p1, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p2, <span class="keyword">const</span> <a class="code" href="classTriangulation_1_1Point.html">Point</a> &amp;p3)
<a name="l00240"></a>00240 {
<a name="l00241"></a>00241     <a class="code" href="classTriangulation_1_1Point.html">Point</a> result = (p1 + p2 + p3) * (1.0/3.0);
<a name="l00242"></a>00242     <span class="keywordtype">double</span> r1 = result.<a class="code" href="classTriangulation_1_1Point.html#a13970d34eb34ff97506cf453283d3ea9">remoteness</a>(p1);
<a name="l00243"></a>00243     <span class="keywordtype">double</span> r2 = result.<a class="code" href="classTriangulation_1_1Point.html#a13970d34eb34ff97506cf453283d3ea9">remoteness</a>(p2);
<a name="l00244"></a>00244     <span class="keywordtype">double</span> r3 = result.<a class="code" href="classTriangulation_1_1Point.html#a13970d34eb34ff97506cf453283d3ea9">remoteness</a>(p3);
<a name="l00245"></a>00245     <span class="keywordtype">double</span> r0 = r1 + r2 + r3;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="comment">//result.color() = (p1.color() + p2.color() + p3.color())/3.0;</span>
<a name="l00248"></a>00248     result.<a class="code" href="classTriangulation_1_1Point.html#ab63e6a647f1d56e24d8c29a1e2baea03">color</a>() = p1.<a class="code" href="classTriangulation_1_1Point.html#ab63e6a647f1d56e24d8c29a1e2baea03">color</a>() * r1/r0 + p2.<a class="code" href="classTriangulation_1_1Point.html#ab63e6a647f1d56e24d8c29a1e2baea03">color</a>() * r2/r0 + p3.<a class="code" href="classTriangulation_1_1Point.html#ab63e6a647f1d56e24d8c29a1e2baea03">color</a>() * r3/r0;
<a name="l00249"></a>00249     <span class="comment">//cout &lt;&lt; &quot;Color1: &quot; &lt;&lt; p1.color() &lt;&lt; &quot; Color2: &quot; &lt;&lt; p2.color() &lt;&lt; &quot; Color3: &quot; &lt;&lt; p3.color()</span>
<a name="l00250"></a>00250     <span class="comment">//        &lt;&lt; &quot; Result: &quot; &lt;&lt; result.color() &lt;&lt; endl;</span>
<a name="l00251"></a>00251     <span class="keywordflow">return</span> result;
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">//////////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00255"></a>00255 <span class="comment"></span><span class="comment">/*std::vector&lt;Edge&gt;    triangulate2(const vector&lt;Point&gt; &amp;points)</span>
<a name="l00256"></a>00256 <span class="comment">{</span>
<a name="l00257"></a>00257 <span class="comment">    set&lt;Edge,    EdgeCmp&gt; edgeMap;</span>
<a name="l00258"></a>00258 <span class="comment">    std::vector&lt;Edge&gt; triangResult = triangulate(points);</span>
<a name="l00259"></a>00259 <span class="comment">    for (vector&lt;Edge&gt;::const_iterator i = triangResult.begin(); i != triangResult.end(); i++)</span>
<a name="l00260"></a>00260 <span class="comment">    {</span>
<a name="l00261"></a>00261 <span class="comment">        // normalize Edge</span>
<a name="l00262"></a>00262 <span class="comment">        if (i-&gt;org &gt; i-&gt;dest)</span>
<a name="l00263"></a>00263 <span class="comment">            edgeMap.insert(Edge(i-&gt;dest, i-&gt;org));</span>
<a name="l00264"></a>00264 <span class="comment">        else</span>
<a name="l00265"></a>00265 <span class="comment">            edgeMap.insert(*i);</span>
<a name="l00266"></a>00266 <span class="comment">    }</span>
<a name="l00267"></a>00267 <span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">    int j = 0;</span>
<a name="l00269"></a>00269 <span class="comment">    std::vector&lt;Edge&gt; result(edgeMap.size());</span>
<a name="l00270"></a>00270 <span class="comment">    for (set&lt;Edge,    EdgeCmp&gt;::const_iterator i = edgeMap.begin(); i != edgeMap.end(); i++)</span>
<a name="l00271"></a>00271 <span class="comment">    {</span>
<a name="l00272"></a>00272 <span class="comment">        //if (i-&gt;org.remoteness(i-&gt;dest) &lt; 300.0)</span>
<a name="l00273"></a>00273 <span class="comment">            result[j++] = *i;</span>
<a name="l00274"></a>00274 <span class="comment">    }</span>
<a name="l00275"></a>00275 <span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">    return result;</span>
<a name="l00277"></a>00277 <span class="comment">}*/</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="preprocessor">#ifndef FAST_SPLIT</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points, TriangulationBeginnings &amp;tb, <a class="code" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> &amp;listOfLists,
<a name="l00281"></a>00281                         <span class="keyword">const</span> <span class="keywordtype">int</span> maxDistance)
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283     list&lt;Point&gt; lpoints;
<a name="l00284"></a>00284     <span class="keywordflow">for</span> (vector&lt;Point&gt;::const_iterator i = points.begin(); i != points.end(); i++)
<a name="l00285"></a>00285         lpoints.push_back(*i);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     <span class="comment">// Creating separate groups to build triangulation for</span>
<a name="l00288"></a>00288     <span class="comment">// O(N^2)</span>
<a name="l00289"></a>00289     <span class="keywordflow">while</span> (!lpoints.empty())
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291         Point current = *lpoints.begin();
<a name="l00292"></a>00292         lpoints.pop_front();
<a name="l00293"></a>00293         <span class="comment">//cout &lt;&lt; &quot;Current: &quot; &lt;&lt; current &lt;&lt; endl;</span>
<a name="l00294"></a>00294 
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296             list&lt;Point&gt; currentList;
<a name="l00297"></a>00297             currentList.push_back(current);
<a name="l00298"></a>00298             listOfLists.push_back(currentList);
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="keywordflow">for</span> (<a class="code" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Lpci</a> point = listOfLists.back().begin(); point != listOfLists.back().end(); point++)
<a name="l00302"></a>00302         {
<a name="l00303"></a>00303             <span class="comment">//cout &lt;&lt; &quot; Current Point: &quot; &lt;&lt; *point &lt;&lt; endl;</span>
<a name="l00304"></a>00304             <span class="keywordflow">for</span> (<a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> secondPoint = lpoints.begin(); secondPoint != lpoints.end();)
<a name="l00305"></a>00305             {
<a name="l00306"></a>00306                 <span class="comment">//cout &lt;&lt; &quot;  &lt;Point: &quot; &lt;&lt; *secondPoint &lt;&lt; &quot;&gt;\n&quot;;     cout.flush();</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         <span class="keywordflow">if</span> (point-&gt;remoteness(*secondPoint) &lt; maxDistance)
<a name="l00309"></a>00309                 {
<a name="l00310"></a>00310                     listOfLists.back().push_back(*secondPoint);
<a name="l00311"></a>00311                     <span class="comment">//cout &lt;&lt; &quot;   Adding point &quot; &lt;&lt; *secondPoint &lt;&lt; &quot;and len is: &quot; &lt;&lt; point-&gt;remoteness(*secondPoint) &lt;&lt;  endl;</span>
<a name="l00312"></a>00312                     <a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> tmpPoint = secondPoint;
<a name="l00313"></a>00313                     secondPoint++;
<a name="l00314"></a>00314                     lpoints.erase(tmpPoint);
<a name="l00315"></a>00315                 }
<a name="l00316"></a>00316                 <span class="keywordflow">else</span>
<a name="l00317"></a>00317                     secondPoint++;
<a name="l00318"></a>00318             }
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     tb.numOfGroups = listOfLists.size();
<a name="l00323"></a>00323     tb.hullEdges.resize(tb.numOfGroups);
<a name="l00324"></a>00324 }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 std::vector&lt;Edge&gt; <a class="code" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">triangulate4</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points, list&lt;Point&gt; &amp;centers, TriangulationBeginnings &amp;tb,
<a name="l00327"></a>00327                                <span class="keyword">const</span> <span class="keywordtype">int</span> maxDistance)
<a name="l00328"></a>00328 {
<a name="l00329"></a>00329     <a class="code" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> listOfLists;
<a name="l00330"></a>00330     <span class="comment">//uint64_t microseconds;</span>
<a name="l00331"></a>00331     <span class="comment">//PreciseTimer timer = PreciseTimer::currentTime();</span>
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     cout &lt;&lt; <span class="stringliteral">&quot;Using slow split algorithm\n&quot;</span>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="comment">// Creating separate groups to build triangulation for</span>
<a name="l00336"></a>00336     <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints started-----\n&quot;;</span>
<a name="l00337"></a>00337   <a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a>(points, tb, listOfLists, maxDistance);
<a name="l00338"></a>00338     <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints finished-----\n&quot;;</span>
<a name="l00339"></a>00339     <span class="comment">//microseconds = timer.usecsTo(PreciseTimer::currentTime());</span>
<a name="l00340"></a>00340     <span class="comment">//cerr &lt;&lt; &quot;splitPoints Real time: &quot; &lt;&lt; microseconds &lt;&lt; &quot; microseconds, &quot; &lt;&lt; microseconds/1000000.0 &lt;&lt; &quot; secs\n&quot;;</span>
<a name="l00341"></a>00341     <span class="comment">//return vector&lt;Edge&gt;();</span>
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     cout &lt;&lt; <span class="stringliteral">&quot;(triangulate4) Points: &quot;</span> &lt;&lt; points.size() &lt;&lt; endl;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345     <span class="keywordtype">size_t</span> countOfEdges = 0;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347     <span class="comment">// array of points to the triangulation</span>
<a name="l00348"></a>00348     vector&lt;Edge&gt; *edges = <span class="keyword">new</span> vector&lt;Edge&gt; [listOfLists.size()];
<a name="l00349"></a>00349 
<a name="l00350"></a>00350     <span class="keywordtype">size_t</span> t = 0;
<a name="l00351"></a>00351     <span class="keywordflow">for</span> (ListOfLists::const_iterator i = listOfLists.begin(); i != listOfLists.end(); i++, t++)
<a name="l00352"></a>00352     {
<a name="l00353"></a>00353         <span class="comment">//cout &lt;&lt; &quot;    size:&quot; &lt;&lt; i-&gt;size() &lt;&lt; endl;</span>
<a name="l00354"></a>00354         <span class="comment">//all += i-&gt;size();</span>
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         vector&lt;Point&gt; newpoints(i-&gt;size());
<a name="l00357"></a>00357         <span class="keywordtype">int</span> k = 0;
<a name="l00358"></a>00358         <span class="keywordflow">for</span> (<a class="code" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Lpci</a> j = i-&gt;begin(); j != i-&gt;end(); j++)
<a name="l00359"></a>00359             newpoints[k++] = *j;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361         edges[t] = <a class="code" href="triangulation_8h.html#a0f3136676982ac4ba38ce4bdbe54b69d">TRIANGULATE</a>(newpoints);
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         <span class="comment">//edges[t] = vector&lt;Edge&gt;();</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (edges[t].size() != 0)
<a name="l00366"></a>00366             tb.hullEdges[t] = countOfEdges;
<a name="l00367"></a>00367         <span class="keywordflow">else</span>
<a name="l00368"></a>00368             tb.hullEdges[t] = -1;
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         countOfEdges += edges[t].size();
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     <span class="comment">//cout &lt;&lt; &quot;Total edges: &quot; &lt;&lt; countOfEdges &lt;&lt; endl;</span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375     vector&lt;Edge&gt; result(countOfEdges);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 0, currentEdgesArray = 0, currentEdgesIndex = 0;
<a name="l00378"></a>00378              currentEdgesArray &lt; listOfLists.size() &amp;&amp; l &lt; countOfEdges;
<a name="l00379"></a>00379              currentEdgesIndex++)
<a name="l00380"></a>00380     {
<a name="l00381"></a>00381         <span class="keywordflow">if</span> (currentEdgesIndex &gt;= edges[currentEdgesArray].size())
<a name="l00382"></a>00382         {
<a name="l00383"></a>00383       <span class="comment">//cout &lt;&lt; &quot;!!! currentEdgesIndex:&quot; &lt;&lt; currentEdgesIndex &lt;&lt; &quot; currentEdgesArray:&quot; &lt;&lt; currentEdgesArray &lt;&lt; endl;</span>
<a name="l00384"></a>00384             currentEdgesIndex = -1;
<a name="l00385"></a>00385             currentEdgesArray++;
<a name="l00386"></a>00386             <span class="keywordflow">continue</span>;
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388         result[l++] = edges[currentEdgesArray][currentEdgesIndex];
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="keywordflow">for</span> (vector&lt;Edge&gt;::const_iterator it = result.begin(); it != result.end(); it += 3)
<a name="l00392"></a>00392         centers.push_back(<a class="code" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">findTriangleCenter</a>(it-&gt;org, it-&gt;dest,
<a name="l00393"></a>00393                                              (it+1)-&gt;dest == it-&gt;dest ? (it+1)-&gt;org : (it+1)-&gt;dest));
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="keyword">delete</span> [] edges;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="comment">// reterning the result with repetition of edegs</span>
<a name="l00398"></a>00398     <span class="keywordflow">return</span> result;
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 <span class="preprocessor">#else</span>
<a name="l00402"></a><a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">00402</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points, <a class="code" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb, <a class="code" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> &amp;listOfLists,
<a name="l00403"></a>00403                         <span class="keyword">const</span> <span class="keywordtype">int</span> maxDistance)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405     list&lt;Point&gt; lpoints;
<a name="l00406"></a>00406     <span class="keywordflow">for</span> (vector&lt;Point&gt;::const_iterator i = points.begin(); i != points.end(); i++)
<a name="l00407"></a>00407         lpoints.push_back(*i);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="comment">// O(N^2)</span>
<a name="l00410"></a>00410     <span class="keywordflow">while</span> (!lpoints.empty())
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412         <a class="code" href="classTriangulation_1_1Point.html">Point</a> current = *lpoints.begin();
<a name="l00413"></a>00413         lpoints.pop_front();
<a name="l00414"></a>00414         <span class="comment">//cout &lt;&lt; &quot;Current: &quot; &lt;&lt; current &lt;&lt; endl;</span>
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         {
<a name="l00417"></a>00417             <a class="code" href="structTriangulation_1_1PointGroup.html">PointGroup</a> currentList;
<a name="l00418"></a>00418             currentList.<a class="code" href="structTriangulation_1_1PointGroup.html#ab8dd015760c56150aef572d9dfe90b98">push_back</a>(current);
<a name="l00419"></a>00419             listOfLists.push_back(currentList);
<a name="l00420"></a>00420         }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         <span class="keywordflow">for</span>(<a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> i = lpoints.begin(); i != lpoints.end();)
<a name="l00423"></a>00423         {
<a name="l00424"></a>00424       <span class="keywordflow">if</span> (listOfLists.back().isNear(*i, maxDistance))
<a name="l00425"></a>00425             {
<a name="l00426"></a>00426                 listOfLists.back().push_back(*i);
<a name="l00427"></a>00427                 <a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> tmpPoint = i;
<a name="l00428"></a>00428                 i++;
<a name="l00429"></a>00429                 lpoints.erase(tmpPoint);
<a name="l00430"></a>00430             }
<a name="l00431"></a>00431             <span class="keywordflow">else</span>
<a name="l00432"></a>00432                 i++;
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434     }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#a194e42b53ff28b0f5bf77f3c3b3094e1">numOfGroups</a> = (int)listOfLists.size();
<a name="l00437"></a>00437     tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>.resize(tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#a194e42b53ff28b0f5bf77f3c3b3094e1">numOfGroups</a>);
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a><a class="code" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">00440</a> std::vector&lt;Edge&gt;    <a class="code" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">triangulate4</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points, list&lt;Point&gt; &amp;centers, <a class="code" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb,
<a name="l00441"></a>00441                                <span class="keyword">const</span> <span class="keywordtype">int</span> maxDistance)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443     <a class="code" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> listOfLists;
<a name="l00444"></a>00444   <span class="comment">//uint64_t microseconds;</span>
<a name="l00445"></a>00445   <span class="comment">//PreciseTimer timer = PreciseTimer::currentTime();</span>
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   cout &lt;&lt; <span class="stringliteral">&quot;Using fast split algorithm\n&quot;</span>;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints started-----\n&quot;;</span>
<a name="l00450"></a>00450   <a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a>(points, tb, listOfLists, maxDistance);
<a name="l00451"></a>00451   <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints finished-----\n&quot;;</span>
<a name="l00452"></a>00452   <span class="comment">//microseconds = timer.usecsTo(PreciseTimer::currentTime());</span>
<a name="l00453"></a>00453   <span class="comment">//cerr &lt;&lt; &quot;splitPoints Real time: &quot; &lt;&lt; microseconds &lt;&lt; &quot; microseconds, &quot; &lt;&lt; microseconds/1000000.0 &lt;&lt; &quot; secs\n&quot;;</span>
<a name="l00454"></a>00454     <span class="comment">//return vector&lt;Edge&gt;();</span>
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     cout &lt;&lt; <span class="stringliteral">&quot;(triangulate4) Points: &quot;</span> &lt;&lt; points.size() &lt;&lt; endl;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="keywordtype">size_t</span> countOfEdges = 0;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     vector&lt;Edge&gt; *edges = <span class="keyword">new</span> vector&lt;Edge&gt; [listOfLists.size()];
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keywordtype">size_t</span> t = 0;
<a name="l00463"></a>00463     <span class="keywordflow">for</span> (ListOfLists::const_iterator i = listOfLists.begin(); i != listOfLists.end(); i++, t++)
<a name="l00464"></a>00464     {
<a name="l00465"></a>00465     <span class="comment">//cout &lt;&lt; &quot;    size:&quot; &lt;&lt; i-&gt;mList.size() &lt;&lt; endl;</span>
<a name="l00466"></a>00466         <span class="comment">//all += i-&gt;size();</span>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     vector&lt;Point&gt; newpoints(i-&gt;mList.size());
<a name="l00469"></a>00469         <span class="keywordtype">int</span> k = 0;
<a name="l00470"></a>00470     <span class="keywordflow">for</span> (<a class="code" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Lpci</a> j = i-&gt;mList.begin(); j != i-&gt;mList.end(); j++)
<a name="l00471"></a>00471             newpoints[k++] = *j;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     edges[t] = <a class="code" href="triangulation_8h.html#a0f3136676982ac4ba38ce4bdbe54b69d">TRIANGULATE</a>(newpoints);
<a name="l00474"></a>00474         <span class="comment">//edges[t] = vector&lt;Edge&gt;();</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476         <span class="keywordflow">if</span> (edges[t].size() != 0)
<a name="l00477"></a>00477             tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>[t] = (int)countOfEdges;
<a name="l00478"></a>00478         <span class="keywordflow">else</span>
<a name="l00479"></a>00479             tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>[t] = -1;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481         countOfEdges += edges[t].size();
<a name="l00482"></a>00482     }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     cout &lt;&lt; <span class="stringliteral">&quot;Total edges: &quot;</span> &lt;&lt; countOfEdges &lt;&lt; endl;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486     vector&lt;Edge&gt; result(countOfEdges);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 0, currentEdgesArray = 0, currentEdgesIndex = 0;
<a name="l00489"></a>00489              currentEdgesArray &lt; listOfLists.size() &amp;&amp; l &lt; countOfEdges;
<a name="l00490"></a>00490              currentEdgesIndex++)
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492         <span class="keywordflow">if</span> (currentEdgesIndex &gt;= edges[currentEdgesArray].size())
<a name="l00493"></a>00493         {
<a name="l00494"></a>00494       <span class="comment">//cout &lt;&lt; &quot;!!! currentEdgesIndex:&quot; &lt;&lt; currentEdgesIndex &lt;&lt; &quot; currentEdgesArray:&quot; &lt;&lt; currentEdgesArray &lt;&lt; endl;</span>
<a name="l00495"></a>00495             currentEdgesIndex = -1;
<a name="l00496"></a>00496             currentEdgesArray++;
<a name="l00497"></a>00497             <span class="keywordflow">continue</span>;
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499         result[l++] = edges[currentEdgesArray][currentEdgesIndex];
<a name="l00500"></a>00500     }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="keywordflow">for</span> (vector&lt;Edge&gt;::const_iterator it = result.begin(); it != result.end(); it += 3)
<a name="l00503"></a>00503     centers.push_back(<a class="code" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">findTriangleCenter</a>(it-&gt;org, it-&gt;dest,
<a name="l00504"></a>00504       (it+1)-&gt;dest == it-&gt;dest ? (it+1)-&gt;org : (it+1)-&gt;dest));
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     <span class="keyword">delete</span> [] edges;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">return</span> result;
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 <span class="preprocessor">#endif</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>
<a name="l00513"></a><a class="code" href="namespaceTriangulation.html#a4a5bf5a2bd444cdeb6deb8befcfe47ab">00513</a> <span class="keywordtype">void</span> <a class="code" href="namespaceTriangulation.html#a4a5bf5a2bd444cdeb6deb8befcfe47ab">printPoints</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points)
<a name="l00514"></a>00514 {
<a name="l00515"></a>00515     cout &lt;&lt; <span class="stringliteral">&quot;printPoints: &quot;</span>;
<a name="l00516"></a>00516     <span class="keywordflow">for</span> (vector&lt;Point&gt;::const_iterator i = points.begin(); i != points.end(); i++)
<a name="l00517"></a>00517         cout &lt;&lt; *i &lt;&lt; endl;
<a name="l00518"></a>00518     cout &lt;&lt; endl;
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a><a class="code" href="namespaceTriangulation.html#a2f04efebed6553f44cb40bf14febbeda">00521</a> std::vector&lt;Edge&gt;    <a class="code" href="namespaceTriangulation.html#a2f04efebed6553f44cb40bf14febbeda">triangulate</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points)
<a name="l00522"></a>00522 {
<a name="l00523"></a>00523     <span class="comment">//printPoints(points);</span>
<a name="l00524"></a>00524     <a class="code" href="classTriangulation_1_1Point.html">Point</a> p;
<a name="l00525"></a>00525     set&lt;Edge,    EdgeCmp&gt; frontier;
<a name="l00526"></a>00526     set&lt;Edge,    EdgeCmp&gt; died;
<a name="l00527"></a>00527     list&lt;vector&lt;Point&gt; &gt; triangles;
<a name="l00528"></a>00528     cout &lt;&lt; <span class="stringliteral">&quot;Using simple triangulation\n&quot;</span>;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="keywordflow">if</span> (points.size() &lt; 3)
<a name="l00531"></a>00531     {
<a name="l00532"></a>00532         cout &lt;&lt; <span class="stringliteral">&quot;(triangulate): No enought data!\n&quot;</span>;
<a name="l00533"></a>00533         <span class="keywordflow">return</span> std::vector&lt;Edge&gt;();
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536     <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> e = <a class="code" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">hullEdge</a>(points);
<a name="l00537"></a>00537     <span class="comment">//cout &lt;&lt; &quot;Hull Edge: &quot; &lt;&lt; e &lt;&lt; endl;</span>
<a name="l00538"></a>00538     frontier.insert(e);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="keywordflow">while</span> (!frontier.empty())
<a name="l00541"></a>00541     {
<a name="l00542"></a>00542         e = *(frontier.begin());
<a name="l00543"></a>00543         frontier.erase(e);
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (<a class="code" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968" title="Searches for the the closest point on the right of the edge.">mate</a>(e, points, p))
<a name="l00546"></a>00546         {
<a name="l00547"></a>00547             <span class="comment">//cout &lt;&lt; &quot;!!!Found mate for &quot; &lt;&lt; e &lt;&lt; &quot; is   &quot; &lt;&lt; p &lt;&lt; endl;</span>
<a name="l00548"></a>00548             died.insert(e);
<a name="l00549"></a>00549             <span class="keywordtype">int</span> r = <a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a>(frontier, p, e.<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>, died);
<a name="l00550"></a>00550             r +=    <a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a>(frontier, e.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>, p, died);
<a name="l00551"></a>00551 
<a name="l00552"></a>00552             <span class="comment">//assert (r == 0);</span>
<a name="l00553"></a>00553             <span class="keywordflow">if</span> (!r)
<a name="l00554"></a>00554             {
<a name="l00555"></a>00555                 vector&lt;Point&gt; triangle(3);
<a name="l00556"></a>00556                 triangle[0] = e.<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a>;
<a name="l00557"></a>00557                 triangle[1] = e.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>;
<a name="l00558"></a>00558                 triangle[2] = p;
<a name="l00559"></a>00559             <span class="comment">//cout &lt;&lt; &quot;    New triangle: &quot; &lt;&lt;p &lt;&lt; &quot;, &quot; &lt;&lt; e.org &lt;&lt; &quot;, &quot; &lt;&lt; e.dest &lt;&lt; endl;</span>
<a name="l00560"></a>00560             triangles.push_back(triangle);
<a name="l00561"></a>00561              }
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     std::vector&lt;Edge&gt; newEdges(triangles.size() * 3);
<a name="l00566"></a>00566     <span class="comment">//list&lt;Edge&gt; newEdges();</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     <span class="comment">//  cout &lt;&lt; &quot;Returning triangles\n&quot;;</span>
<a name="l00570"></a>00570     <span class="keywordtype">int</span> j = 0;
<a name="l00571"></a>00571     <span class="keywordflow">for</span> (list&lt;vector&lt;Point&gt; &gt;::const_iterator i = triangles.begin(); i != triangles.end(); i++)
<a name="l00572"></a>00572     {
<a name="l00573"></a>00573         <span class="comment">/*newEdges.push_back(Edge((*i)[0], (*i)[1]));</span>
<a name="l00574"></a>00574 <span class="comment">        newEdges.push_back(Edge((*i)[1], (*i)[2]));</span>
<a name="l00575"></a>00575 <span class="comment">        newEdges.push_back(Edge((*i)[2], (*i)[0]));*/</span>
<a name="l00576"></a>00576         newEdges[j].org = (*i)[0];
<a name="l00577"></a>00577         newEdges[j++].dest = (*i)[1];
<a name="l00578"></a>00578         newEdges[j].org = (*i)[1];
<a name="l00579"></a>00579         newEdges[j++].dest = (*i)[2];
<a name="l00580"></a>00580         newEdges[j].org = (*i)[2];
<a name="l00581"></a>00581         newEdges[j++].dest = (*i)[0];
<a name="l00582"></a>00582     }
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     cout &lt;&lt; <span class="stringliteral">&quot;Triangles:&quot;</span> &lt;&lt; triangles.size() &lt;&lt; <span class="stringliteral">&quot; Edges: &quot;</span> &lt;&lt; newEdges.size() &lt;&lt; <span class="stringliteral">&quot; Points: &quot;</span> &lt;&lt; points.size() &lt;&lt; endl;
<a name="l00585"></a>00585     <span class="keywordflow">return</span> newEdges;
<a name="l00586"></a>00586 }
<a name="l00587"></a>00587 
<a name="l00588"></a><a class="code" href="namespaceTriangulation.html#afc6d99d4d3840905bf21f1feba1efd9b">00588</a> std::vector&lt;Edge&gt; <a class="code" href="namespaceTriangulation.html#afc6d99d4d3840905bf21f1feba1efd9b">vertexHull</a>(<span class="keyword">const</span> vector&lt;Point&gt; &amp;points)
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590     <span class="keywordflow">if</span> (points.size() &lt; 3)
<a name="l00591"></a>00591     {
<a name="l00592"></a>00592         cout &lt;&lt; <span class="stringliteral">&quot;No enought data!\n&quot;</span>;
<a name="l00593"></a>00593         <span class="keywordflow">return</span> std::vector&lt;Edge&gt;();
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     list&lt;Point&gt; tmp;
<a name="l00597"></a>00597     <a class="code" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> tb;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     std::vector&lt;Edge&gt; triangulations = <a class="code" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">triangulate4</a>(points, tmp, tb);
<a name="l00600"></a>00600     <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">vertexHullFromTriangulation</a>(triangulations, (<span class="keywordtype">int</span>)points.size(), tb);
<a name="l00601"></a>00601 }
<a name="l00602"></a>00602 
<a name="l00603"></a><a class="code" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">00603</a> std::vector&lt;Edge&gt; <a class="code" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">vertexHullFromTriangulation</a>(<span class="keyword">const</span> std::vector&lt;Edge&gt; &amp;edges, <span class="keyword">const</span> <span class="keywordtype">int</span> pointsCount,
<a name="l00604"></a>00604                                               <span class="keyword">const</span> <a class="code" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb)
<a name="l00605"></a>00605 {
<a name="l00606"></a>00606     <span class="keywordtype">int</span> i = 0;
<a name="l00607"></a>00607     std::vector&lt;Edge&gt; result(pointsCount);
<a name="l00608"></a>00608     multimap&lt;Point, Edge&gt; edgeList;
<a name="l00609"></a>00609     multimap&lt;Point, Edge&gt;::const_iterator it;
<a name="l00610"></a>00610     pair&lt;multimap&lt;Point, Edge&gt;::iterator, multimap&lt;Point, Edge&gt;::iterator&gt; ret;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">// creating data structure in which it is easy to find the edges originating from a given point</span>
<a name="l00613"></a>00613     <span class="keywordflow">for</span> (vector&lt;Edge&gt;::const_iterator i = edges.begin() + 1; i != edges.end(); i++)
<a name="l00614"></a>00614         edgeList.insert(make_pair(i-&gt;org, *i));
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     <span class="comment">//cout &lt;&lt; &quot;========================\n&quot;;</span>
<a name="l00618"></a>00618     <a class="code" href="classTriangulation_1_1Point.html">Point</a> point0 = edges[0].org;
<a name="l00619"></a>00619     <span class="comment">//cout &lt;&lt; &quot;Point0 :&quot; &lt;&lt; point0 &lt;&lt; &quot; Point1 :&quot; &lt;&lt; edges[0].dest &lt;&lt; endl;</span>
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 
<a name="l00622"></a>00622     <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> cur;
<a name="l00623"></a>00623     <span class="keywordtype">bool</span> firstIteration = <span class="keyword">true</span>;
<a name="l00624"></a>00624     <span class="keywordtype">int</span> groupCounter = -1;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626     <span class="comment">//cout &lt;&lt; &quot;tb.numOfGroups: &quot; &lt;&lt; tb.numOfGroups &lt;&lt; endl;</span>
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="keywordflow">while</span> (groupCounter &lt; tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#a194e42b53ff28b0f5bf77f3c3b3094e1">numOfGroups</a>)
<a name="l00629"></a>00629     {
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (cur.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> == point0 || firstIteration)
<a name="l00631"></a>00631         {
<a name="l00632"></a>00632             firstIteration = <span class="keyword">false</span>;
<a name="l00633"></a>00633             groupCounter ++;
<a name="l00634"></a>00634 
<a name="l00635"></a>00635             <span class="keywordflow">if</span> (groupCounter == tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#a194e42b53ff28b0f5bf77f3c3b3094e1">numOfGroups</a>)
<a name="l00636"></a>00636                 <span class="keywordflow">break</span>;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638             <span class="keywordflow">if</span> (tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>[groupCounter] == -1)
<a name="l00639"></a>00639             {
<a name="l00640"></a>00640                 groupCounter++;
<a name="l00641"></a>00641                 <span class="keywordflow">continue</span>;
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644             <span class="comment">//cout &lt;&lt; &quot;|||Next group : &quot; &lt;&lt; tb.hullEdges[groupCounter] &lt;&lt; endl;</span>
<a name="l00645"></a>00645             cur.<a class="code" href="classTriangulation_1_1Edge.html#aac63dac7f726d09086947d54ec2b1be0">org</a> = point0 = edges[tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>[groupCounter]].org;
<a name="l00646"></a>00646             cur.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a> = edges[tb.<a class="code" href="structTriangulation_1_1TriangulationBeginnings.html#ae6f5f0ed63822e28e72598b930709c07">hullEdges</a>[groupCounter]].dest;
<a name="l00647"></a>00647             result[i++] = cur;
<a name="l00648"></a>00648             <span class="keywordflow">continue</span>;
<a name="l00649"></a>00649         }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         <span class="comment">// searching all outgoing edges form the given point</span>
<a name="l00652"></a>00652         ret = edgeList.equal_range(cur.<a class="code" href="classTriangulation_1_1Edge.html#a5dfa879cc89542f98f636433446fd5be">dest</a>);
<a name="l00653"></a>00653         <span class="comment">//cout &lt;&lt; &quot;    &quot; &lt;&lt; cur.dest &lt;&lt; &quot;:::: \n&quot;;</span>
<a name="l00654"></a>00654         <span class="keywordtype">double</span> maxAngle = -1.1;
<a name="l00655"></a>00655         <a class="code" href="classTriangulation_1_1Edge.html">Edge</a> maxEdge;
<a name="l00656"></a>00656         <span class="keywordflow">for</span> (it = ret.first; it!=ret.second; ++it)
<a name="l00657"></a>00657         {
<a name="l00658"></a>00658             <span class="comment">//     cout &lt;&lt; &quot;        &quot; &lt;&lt; (*it).second &lt;&lt; endl;</span>
<a name="l00659"></a>00659                  <span class="keywordtype">double</span> angle = cur.<a class="code" href="classTriangulation_1_1Edge.html#a730bfe3d681de1b86180b19deb1676a8">cosAngle</a>((*it).second); <span class="comment">// cosinus</span>
<a name="l00660"></a>00660                  <span class="keywordflow">if</span> (angle &gt; maxAngle)
<a name="l00661"></a>00661                  {
<a name="l00662"></a>00662                      maxAngle = angle;
<a name="l00663"></a>00663                      maxEdge = (*it).second;
<a name="l00664"></a>00664                  }
<a name="l00665"></a>00665         }
<a name="l00666"></a>00666         <span class="comment">//cout &lt;&lt; &quot;    maxAngle: &quot; &lt;&lt; maxAngle &lt;&lt; &quot; maxEdge: &quot; &lt;&lt; maxEdge &lt;&lt; endl;</span>
<a name="l00667"></a>00667         cur = maxEdge;
<a name="l00668"></a>00668         result[i++] = maxEdge;
<a name="l00669"></a>00669     }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671     <span class="keywordflow">return</span> result;
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 23:44:36 for DeepView by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
