<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DeepView: Triangulation Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DeepView
   &#160;<span id="projectnumber">0.02</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Triangulation Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation_1_1Point.html">Point</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation_1_1Edge.html">Edge</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1EdgeCmp.html">EdgeCmp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1PointGroup.html">PointGroup</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a0324dce9b522fe588d7be112ea3f4ad8">ElementType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef list&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt;<br class="typebreak"/>
::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Lpci</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef list&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef list&lt; <a class="el" href="structTriangulation_1_1PointGroup.html">PointGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9">LEFT</a> =  0, 
<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4">RIGHT</a> =  1, 
<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b">BEYOND</a> =  2, 
<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7">BEHIND</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751">BETWEEN</a> =  4, 
<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af">ORIGIN</a> =  5, 
<a class="el" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760">DESTINATION</a> =  6
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of the point with respect to the directed edge.  <a href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da721113e201ab78b3738e0213968c0ed3">COLLINEAR</a> =  0, 
<a class="el" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3daf513e755b8a314976060dd1bbb322bde">PARALLEL</a> =  1, 
<a class="el" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04">SKEW</a> =  2, 
<a class="el" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3dac8ca755e4c8bccc48d95d1eeee87d3a1">SKEW_CROSS</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da34ee95a8c50329209d5cedca65553913">SKEW_NO_CROSS</a> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a0efabaf278bfbb4770d073801d480667">orientation</a> (const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p0, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p1, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a7a00d0364de4be64bf16fcf9452d31d2">doubleEqual</a> (const double a, const double b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison precise up to epsilon  <a href="#a7a00d0364de4be64bf16fcf9452d31d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">classify</a> (const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;dest, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;org, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968">mate</a> (const <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e, const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points, <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the the closest point on the right of the edge.  <a href="#a9ef1039efb177f4f7bb19ae4b6c46968"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">hullEdge</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a> (set&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a>, <a class="el" href="structTriangulation_1_1EdgeCmp.html">EdgeCmp</a> &gt; &amp;frontier, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;a, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;b, set&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a>, <a class="el" href="structTriangulation_1_1EdgeCmp.html">EdgeCmp</a> &gt; &amp;died)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#ab38d7ad94fc43883068b0df2550efa94">isInsideTriangle</a> (const <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e1, const <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e2, const <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &amp;e3, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation_1_1Point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">findTriangleCenter</a> (const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p1, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p2, const <a class="el" href="classTriangulation_1_1Point.html">Point</a> &amp;p3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points, <a class="el" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb, <a class="el" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> &amp;listOfLists, const int maxDistance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">triangulate4</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points, list&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;centers, <a class="el" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb, const int maxDistance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a4a5bf5a2bd444cdeb6deb8befcfe47ab">printPoints</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a2f04efebed6553f44cb40bf14febbeda">triangulate</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#afc6d99d4d3840905bf21f1feba1efd9b">vertexHull</a> (const vector&lt; <a class="el" href="classTriangulation_1_1Point.html">Point</a> &gt; &amp;points)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">vertexHullFromTriangulation</a> (const std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt; &amp;edges, const int pointsCount, const <a class="el" href="structTriangulation_1_1TriangulationBeginnings.html">TriangulationBeginnings</a> &amp;tb)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#a56b844197167a7e205b51af676782dc2">DEFAULT_MAX_DISTANCE</a> = 200.0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTriangulation.html#afa0cc00702ac5ec0a1a149038e77e24f">EPSILON</a> = 0.00001</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0324dce9b522fe588d7be112ea3f4ad8"></a><!-- doxytag: member="Triangulation::ElementType" ref="a0324dce9b522fe588d7be112ea3f4ad8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceTriangulation.html#a0324dce9b522fe588d7be112ea3f4ad8">Triangulation::ElementType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00047">47</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8dfdfb7b59b3e760ba74b5e1ec5af3c9"></a><!-- doxytag: member="Triangulation::ListOfLists" ref="a8dfdfb7b59b3e760ba74b5e1ec5af3c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;<a class="el" href="structTriangulation_1_1PointGroup.html">PointGroup</a>&gt; <a class="el" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">Triangulation::ListOfLists</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00310">310</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea0dc50942b8a3354ce53d192b202a1b"></a><!-- doxytag: member="Triangulation::Lpci" ref="aea0dc50942b8a3354ce53d192b202a1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;<a class="el" href="classTriangulation_1_1Point.html">Point</a>&gt;::const_iterator <a class="el" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Triangulation::Lpci</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00259">259</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a79739962b58846e97b6db47dcdbe28"></a><!-- doxytag: member="Triangulation::Lpi" ref="a6a79739962b58846e97b6db47dcdbe28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef list&lt;<a class="el" href="classTriangulation_1_1Point.html">Point</a>&gt;::iterator <a class="el" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Triangulation::Lpi</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00260">260</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3"></a><!-- doxytag: member="Triangulation::@0" ref="a18483166c3074c05b24fb6b65505f7a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Position of the point with respect to the directed edge. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9"></a><!-- doxytag: member="LEFT" ref="a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9" args="" -->LEFT</em>&nbsp;</td><td>
<p><a class="el" href="classTriangulation_1_1Point.html">Point</a> is to the left of the edge. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4"></a><!-- doxytag: member="RIGHT" ref="a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" args="" -->RIGHT</em>&nbsp;</td><td>
<p><a class="el" href="classTriangulation_1_1Point.html">Point</a> is to the right of the edge. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b"></a><!-- doxytag: member="BEYOND" ref="a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b" args="" -->BEYOND</em>&nbsp;</td><td>
<p><a class="el" href="classTriangulation_1_1Point.html">Point</a> is on the same line as the edge but beyond the end. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7"></a><!-- doxytag: member="BEHIND" ref="a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7" args="" -->BEHIND</em>&nbsp;</td><td>
<p><a class="el" href="classTriangulation_1_1Point.html">Point</a> is on the same line as the edge but before the start. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751"></a><!-- doxytag: member="BETWEEN" ref="a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" args="" -->BETWEEN</em>&nbsp;</td><td>
<p>The point is on the edge. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af"></a><!-- doxytag: member="ORIGIN" ref="a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" args="" -->ORIGIN</em>&nbsp;</td><td>
<p>The point is the origin. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760"></a><!-- doxytag: member="DESTINATION" ref="a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760" args="" -->DESTINATION</em>&nbsp;</td><td>
<p>The point is the destination. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00155">155</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9" title="Point is to the left of the edge.">LEFT</a> = 0, <span class="comment">/**&lt; Point is to the left of the edge */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> = 1, <span class="comment">/**&lt; Point is to the right of the edge */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b" title="Point is on the same line as the edge but beyond the end.">BEYOND</a> = 2, <span class="comment">/**&lt; Point is on the same line as the edge but beyond the end */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7" title="Point is on the same line as the edge but before the start.">BEHIND</a> = 3, <span class="comment">/**&lt; Point is on the same line as the edge but before the start */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> = 4, <span class="comment">/**&lt; The point is on the edge */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a> = 5, <span class="comment">/**&lt; The point is the origin */</span>
    <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760" title="The point is the destination.">DESTINATION</a> = 6<span class="comment"></span>
<span class="comment">/**&lt; The point is the destination */</span>
};
</pre></div>
</div>
</div>
<a class="anchor" id="a0a48495ce425f513994be17624f89a3d"></a><!-- doxytag: member="Triangulation::@1" ref="a0a48495ce425f513994be17624f89a3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0a48495ce425f513994be17624f89a3da721113e201ab78b3738e0213968c0ed3"></a><!-- doxytag: member="COLLINEAR" ref="a0a48495ce425f513994be17624f89a3da721113e201ab78b3738e0213968c0ed3" args="" -->COLLINEAR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a48495ce425f513994be17624f89a3daf513e755b8a314976060dd1bbb322bde"></a><!-- doxytag: member="PARALLEL" ref="a0a48495ce425f513994be17624f89a3daf513e755b8a314976060dd1bbb322bde" args="" -->PARALLEL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04"></a><!-- doxytag: member="SKEW" ref="a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04" args="" -->SKEW</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a48495ce425f513994be17624f89a3dac8ca755e4c8bccc48d95d1eeee87d3a1"></a><!-- doxytag: member="SKEW_CROSS" ref="a0a48495ce425f513994be17624f89a3dac8ca755e4c8bccc48d95d1eeee87d3a1" args="" -->SKEW_CROSS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a48495ce425f513994be17624f89a3da34ee95a8c50329209d5cedca65553913"></a><!-- doxytag: member="SKEW_NO_CROSS" ref="a0a48495ce425f513994be17624f89a3da34ee95a8c50329209d5cedca65553913" args="" -->SKEW_NO_CROSS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00167">167</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da721113e201ab78b3738e0213968c0ed3">COLLINEAR</a> = 0, <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3daf513e755b8a314976060dd1bbb322bde">PARALLEL</a> = 1, <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04">SKEW</a> = 2, <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3dac8ca755e4c8bccc48d95d1eeee87d3a1">SKEW_CROSS</a> = 3, <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da34ee95a8c50329209d5cedca65553913">SKEW_NO_CROSS</a> = 4
};
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6bacdcc5b47e8f998db5e880477c5614"></a><!-- doxytag: member="Triangulation::classify" ref="a6bacdcc5b47e8f998db5e880477c5614" args="(const Point &amp;dest, const Point &amp;org, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">Triangulation::classify</a> </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>org</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00101">101</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00160">BEHIND</a>, <a class="el" href="triangulation_8h_source.html#l00161">BETWEEN</a>, <a class="el" href="triangulation_8h_source.html#l00159">BEYOND</a>, <a class="el" href="triangulation_8h_source.html#l00163">DESTINATION</a>, <a class="el" href="triangulation_8h_source.html#l00157">LEFT</a>, <a class="el" href="triangulation_8h_source.html#l00120">Triangulation::Point::length()</a>, <a class="el" href="triangulation_8h_source.html#l00162">ORIGIN</a>, <a class="el" href="triangulation_8h_source.html#l00158">RIGHT</a>, <a class="el" href="vector2d_8h_source.html#l00050">corecvs::Vector2d&lt; ElementType &gt;::x()</a>, and <a class="el" href="vector2d_8h_source.html#l00055">corecvs::Vector2d&lt; ElementType &gt;::y()</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8h_source.html#l00194">Triangulation::Edge::classify()</a>, and <a class="el" href="triangulation_8cpp_source.html#l00164">hullEdge()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Point a = dest - org;
    Point b = p2 - org;

    <span class="keywordtype">double</span> sa = a.x() * b.y() - b.x() * a.y();

    <span class="keywordflow">if</span> (sa &gt; 0.0)
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sa &lt; 0.0)
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a75b7dc10cc59c6044675353c06b28da9" title="Point is to the left of the edge.">LEFT</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((a.x() * b.x() &lt; 0.0) || (a.y() * b.y() &lt; 0.0))
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3aedaed2593b54e34fa1968a0c9bfb66f7" title="Point is on the same line as the edge but before the start.">BEHIND</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a.length() &lt; b.length())
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a442bad34ab4bd3b7d9967898eed36d1b" title="Point is on the same line as the edge but beyond the end.">BEYOND</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (org == p2)
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dest == p2)
        <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a72eedb4044a049b56bcfb9ff86bfa760" title="The point is the destination.">DESTINATION</a>;
    <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a6bacdcc5b47e8f998db5e880477c5614_cgraph.svg" width="584" height="147"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7a00d0364de4be64bf16fcf9452d31d2"></a><!-- doxytag: member="Triangulation::doubleEqual" ref="a7a00d0364de4be64bf16fcf9452d31d2" args="(const double a, const double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceTriangulation.html#a7a00d0364de4be64bf16fcf9452d31d2">Triangulation::doubleEqual</a> </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>comparison precise up to epsilon </p>

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00065">65</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00043">EPSILON</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00070">Triangulation::Edge::intersect()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> (fabs(a-b) &lt; <a class="code" href="distortionWidget_8cpp.html#a596344e5a2992d2beec43b76a6294de0">EPSILON</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a80f248d30ab0a769a04a9bbbabc262bf"></a><!-- doxytag: member="Triangulation::findTriangleCenter" ref="a80f248d30ab0a769a04a9bbbabc262bf" args="(const Point &amp;p1, const Point &amp;p2, const Point &amp;p3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation_1_1Point.html">Point</a> <a class="el" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">Triangulation::findTriangleCenter</a> </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00239">239</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00131">Triangulation::Point::color()</a>, and <a class="el" href="triangulation_8h_source.html#l00125">Triangulation::Point::remoteness()</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00440">triangulate4()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Point result = (p1 + p2 + p3) * (1.0/3.0);
    <span class="keywordtype">double</span> r1 = result.remoteness(p1);
    <span class="keywordtype">double</span> r2 = result.remoteness(p2);
    <span class="keywordtype">double</span> r3 = result.remoteness(p3);
    <span class="keywordtype">double</span> r0 = r1 + r2 + r3;

    <span class="comment">//result.color() = (p1.color() + p2.color() + p3.color())/3.0;</span>
    result.color() = p1.color() * r1/r0 + p2.color() * r2/r0 + p3.color() * r3/r0;
    <span class="comment">//cout &lt;&lt; &quot;Color1: &quot; &lt;&lt; p1.color() &lt;&lt; &quot; Color2: &quot; &lt;&lt; p2.color() &lt;&lt; &quot; Color3: &quot; &lt;&lt; p3.color()</span>
    <span class="comment">//        &lt;&lt; &quot; Result: &quot; &lt;&lt; result.color() &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> result;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a80f248d30ab0a769a04a9bbbabc262bf_cgraph.svg" width="510" height="94"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6a73b792348995b70f3668e272850db7"></a><!-- doxytag: member="Triangulation::hullEdge" ref="a6a73b792348995b70f3668e272850db7" args="(const vector&lt; Point &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation_1_1Edge.html">Edge</a> <a class="el" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">Triangulation::hullEdge</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00164">164</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00161">BETWEEN</a>, <a class="el" href="triangulation_8cpp_source.html#l00101">classify()</a>, and <a class="el" href="triangulation_8h_source.html#l00158">RIGHT</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00521">triangulate()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> m = 0;
    <span class="keywordtype">size_t</span> i;

    <span class="keywordflow">for</span> (i = 1; i &lt; points.size(); i++)
    {
        <span class="keywordflow">if</span> (points[i] &lt; points[m])
            m = i;
    }
    <span class="keywordtype">size_t</span> min = m; <span class="comment">// &quot;minimal point&quot;</span>
    m = 0;
    i = 1;

    <span class="comment">// processing the marginal situations, when &quot;minimal point&quot; is one of the first ones</span>
    <span class="keywordflow">if</span> (min == 0)
    {
        m = 1;
        i = 2;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (min == 1)
        i = 2;

    <span class="comment">// serching for the seconf point of the &quot;minimum edge&quot;</span>
    <span class="keywordflow">for</span> (; i &lt; points.size(); i++)
    {
        <span class="keywordflow">if</span> (i == min)
            <span class="keywordflow">continue</span>;

        <span class="keywordtype">int</span> c = <a class="code" href="namespaceTriangulation.html#a6bacdcc5b47e8f998db5e880477c5614">classify</a>(points[min], points[m], points[i]);
        <span class="keywordflow">if</span> (c  ==  <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || c  == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a>)
            m = i;
    }

    <span class="keywordflow">return</span> Edge(points[min], points[m]);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a6a73b792348995b70f3668e272850db7_cgraph.svg" width="100%" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab38d7ad94fc43883068b0df2550efa94"></a><!-- doxytag: member="Triangulation::isInsideTriangle" ref="ab38d7ad94fc43883068b0df2550efa94" args="(const Edge &amp;e1, const Edge &amp;e2, const Edge &amp;e3, const Point &amp;point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceTriangulation.html#ab38d7ad94fc43883068b0df2550efa94">Triangulation::isInsideTriangle</a> </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00228">228</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00161">BETWEEN</a>, <a class="el" href="triangulation_8h_source.html#l00194">Triangulation::Edge::classify()</a>, <a class="el" href="triangulation_8h_source.html#l00162">ORIGIN</a>, and <a class="el" href="triangulation_8h_source.html#l00158">RIGHT</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//RIGHT BETWEEN ORIGIN DESTINATION</span>
    <span class="keywordflow">if</span> ( (e1.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e1.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e1.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>) &amp;&amp;
             (e2.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e2.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e2.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>) &amp;&amp;
             (e3.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a> || e3.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a7366fbbf027f6b087c30e4313fda5751" title="The point is on the edge.">BETWEEN</a> || e3.classify(point) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3ac807850eab6326c37420c65b849e43af" title="The point is the origin.">ORIGIN</a>))
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_ab38d7ad94fc43883068b0df2550efa94_cgraph.svg" width="100%" height="150"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9ef1039efb177f4f7bb19ae4b6c46968"></a><!-- doxytag: member="Triangulation::mate" ref="a9ef1039efb177f4f7bb19ae4b6c46968" args="(const Edge &amp;e, const vector&lt; Point &gt; &amp;points, Point &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968">Triangulation::mate</a> </td>
          <td>(</td>
          <td class="paramtype">const Edge &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches for the the closest point on the right of the edge. </p>
<p>Condition is that the circle around given 3 points should not contain other points </p>

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00128">128</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00194">Triangulation::Edge::classify()</a>, <a class="el" href="triangulation_8h_source.html#l00178">Triangulation::Edge::dest</a>, <a class="el" href="triangulation_8cpp_source.html#l00070">Triangulation::Edge::intersect()</a>, <a class="el" href="triangulation_8h_source.html#l00158">RIGHT</a>, <a class="el" href="triangulation_8cpp_source.html#l00050">Triangulation::Edge::rot()</a>, <a class="el" href="triangulation_8h_source.html#l00169">SKEW</a>, <a class="el" href="vector2d_8h_source.html#l00050">corecvs::Vector2d&lt; ElementType &gt;::x()</a>, and <a class="el" href="vector2d_8h_source.html#l00055">corecvs::Vector2d&lt; ElementType &gt;::y()</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00521">triangulate()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Point bestp(0,0);
        <span class="keywordtype">double</span> t, bestt = std::numeric_limits&lt;double&gt;::max();
    Edge f = e;

    f.rot();      <span class="comment">// f - perpendicular to the center of the segment ะต</span>
    <span class="comment">//cout &lt;&lt; &quot;enum {LEFT = 0,  RIGHT = 1,  BEYOND = 2,  BEHIND = 3, BETWEEN = 4, ORIGIN = 5, DESTINATION = 6};\n&quot;;</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; points.size(); i++)
    {
        <span class="comment">//cout &lt;&lt; &quot;    Classify: &quot; &lt;&lt; points[i] &lt;&lt; &quot; for &quot; &lt;&lt; e &lt;&lt; &quot; is: &quot; &lt;&lt; e.classify(points[i]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> (e.classify(points[i]) == <a class="code" href="namespaceTriangulation.html#a18483166c3074c05b24fb6b65505f7a3a5bb0ef36b7a4a1033a7bc03570b78fb4" title="Point is to the right of the edge.">RIGHT</a>)
        {
            Edge g(e.dest, points[i]);
            g.rot();
            <span class="keywordtype">int</span> intersect = f.intersect (g, t);
            <span class="comment">//cout &lt;&lt; &quot;        enum {COLLINEAR = 0, PARALLEL = 1, SKEW = 2, SKEW_CROSS = 3, SKEW_NO_CROSS = 4 }\n &quot;;</span>
            <span class="comment">//cout        &lt;&lt; &quot;intersecting: &quot; &lt;&lt; f &lt;&lt; &quot; and &quot; &lt;&lt; g &lt;&lt; &quot;. intersect = : &quot; &lt;&lt; intersect &lt;&lt; &quot;, t = &quot; &lt;&lt; t &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> (t &lt; bestt &amp;&amp; intersect == <a class="code" href="namespaceTriangulation.html#a0a48495ce425f513994be17624f89a3da8bfabdb3d31dd27624f9871138ac0b04">SKEW</a> )
            {
                bestp = points[i];
                bestt = t;
            }
        }
    }

    <span class="keywordflow">if</span> ((bestp.x() != 0) &amp;&amp; (bestp.y() != 0))
    {
        p = bestp;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a9ef1039efb177f4f7bb19ae4b6c46968_cgraph.svg" width="100%" height="209"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0efabaf278bfbb4770d073801d480667"></a><!-- doxytag: member="Triangulation::orientation" ref="a0efabaf278bfbb4770d073801d480667" args="(const Point &amp;p0, const Point &amp;p1, const Point &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceTriangulation.html#a0efabaf278bfbb4770d073801d480667">Triangulation::orientation</a> </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00018">18</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="vector2d_8h_source.html#l00143">corecvs::Vector2d&lt; ElementType &gt;::triangleOrientedAreaTo()</a>.</p>
<div class="fragment"><pre class="fragment">{
    Point a = p1  - p0;
    Point b = p2  - p0;

    <span class="comment">//double sa = a.x() * b.y() - b.x() * a.y();</span>
  <span class="keywordtype">double</span> sa = a.triangleOrientedAreaTo(b);

    <span class="keywordflow">if</span> (sa &gt; 0.0)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sa &lt; 0.0)
        <span class="keywordflow">return</span> -1;
    <span class="keywordflow">return</span> 0;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a0efabaf278bfbb4770d073801d480667_cgraph.svg" width="528" height="40"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4a5bf5a2bd444cdeb6deb8befcfe47ab"></a><!-- doxytag: member="Triangulation::printPoints" ref="a4a5bf5a2bd444cdeb6deb8befcfe47ab" args="(const vector&lt; Point &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceTriangulation.html#a4a5bf5a2bd444cdeb6deb8befcfe47ab">Triangulation::printPoints</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00513">513</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    cout &lt;&lt; <span class="stringliteral">&quot;printPoints: &quot;</span>;
    <span class="keywordflow">for</span> (vector&lt;Point&gt;::const_iterator i = points.begin(); i != points.end(); i++)
        cout &lt;&lt; *i &lt;&lt; endl;
    cout &lt;&lt; endl;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ccdc1b0b225bde006f9e12fbcf0ab16"></a><!-- doxytag: member="Triangulation::splitPoints" ref="a7ccdc1b0b225bde006f9e12fbcf0ab16" args="(const vector&lt; Point &gt; &amp;points, TriangulationBeginnings &amp;tb, ListOfLists &amp;listOfLists, const int maxDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">Triangulation::splitPoints</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangulationBeginnings &amp;&#160;</td>
          <td class="paramname"><em>tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListOfLists &amp;&#160;</td>
          <td class="paramname"><em>listOfLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00402">402</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00237">Triangulation::TriangulationBeginnings::hullEdges</a>, <a class="el" href="triangulation_8h_source.html#l00236">Triangulation::TriangulationBeginnings::numOfGroups</a>, and <a class="el" href="triangulation_8h_source.html#l00275">Triangulation::PointGroup::push_back()</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00440">triangulate4()</a>.</p>
<div class="fragment"><pre class="fragment">{
    list&lt;Point&gt; lpoints;
    <span class="keywordflow">for</span> (vector&lt;Point&gt;::const_iterator i = points.begin(); i != points.end(); i++)
        lpoints.push_back(*i);

    <span class="comment">// O(N^2)</span>
    <span class="keywordflow">while</span> (!lpoints.empty())
    {
        Point current = *lpoints.begin();
        lpoints.pop_front();
        <span class="comment">//cout &lt;&lt; &quot;Current: &quot; &lt;&lt; current &lt;&lt; endl;</span>

        {
            PointGroup currentList;
            currentList.push_back(current);
            listOfLists.push_back(currentList);
        }

        <span class="keywordflow">for</span>(<a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> i = lpoints.begin(); i != lpoints.end();)
        {
      <span class="keywordflow">if</span> (listOfLists.back().isNear(*i, maxDistance))
            {
                listOfLists.back().push_back(*i);
                <a class="code" href="namespaceTriangulation.html#a6a79739962b58846e97b6db47dcdbe28">Lpi</a> tmpPoint = i;
                i++;
                lpoints.erase(tmpPoint);
            }
            <span class="keywordflow">else</span>
                i++;
        }
    }

    tb.numOfGroups = (int)listOfLists.size();
    tb.hullEdges.resize(tb.numOfGroups);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a7ccdc1b0b225bde006f9e12fbcf0ab16_cgraph.svg" width="100%" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2f04efebed6553f44cb40bf14febbeda"></a><!-- doxytag: member="Triangulation::triangulate" ref="a2f04efebed6553f44cb40bf14febbeda" args="(const vector&lt; Point &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt; <a class="el" href="namespaceTriangulation.html#a2f04efebed6553f44cb40bf14febbeda">Triangulation::triangulate</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00521">521</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8h_source.html#l00178">Triangulation::Edge::dest</a>, <a class="el" href="triangulation_8cpp_source.html#l00164">hullEdge()</a>, <a class="el" href="triangulation_8cpp_source.html#l00128">mate()</a>, <a class="el" href="triangulation_8h_source.html#l00177">Triangulation::Edge::org</a>, and <a class="el" href="triangulation_8cpp_source.html#l00203">updateFrontier()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//printPoints(points);</span>
    Point p;
    set&lt;Edge,    EdgeCmp&gt; frontier;
    set&lt;Edge,    EdgeCmp&gt; died;
    list&lt;vector&lt;Point&gt; &gt; triangles;
    cout &lt;&lt; <span class="stringliteral">&quot;Using simple triangulation\n&quot;</span>;

    <span class="keywordflow">if</span> (points.size() &lt; 3)
    {
        cout &lt;&lt; <span class="stringliteral">&quot;(triangulate): No enought data!\n&quot;</span>;
        <span class="keywordflow">return</span> std::vector&lt;Edge&gt;();
    }

    Edge e = <a class="code" href="namespaceTriangulation.html#a6a73b792348995b70f3668e272850db7">hullEdge</a>(points);
    <span class="comment">//cout &lt;&lt; &quot;Hull Edge: &quot; &lt;&lt; e &lt;&lt; endl;</span>
    frontier.insert(e);

    <span class="keywordflow">while</span> (!frontier.empty())
    {
        e = *(frontier.begin());
        frontier.erase(e);

        <span class="keywordflow">if</span> (<a class="code" href="namespaceTriangulation.html#a9ef1039efb177f4f7bb19ae4b6c46968" title="Searches for the the closest point on the right of the edge.">mate</a>(e, points, p))
        {
            <span class="comment">//cout &lt;&lt; &quot;!!!Found mate for &quot; &lt;&lt; e &lt;&lt; &quot; is   &quot; &lt;&lt; p &lt;&lt; endl;</span>
            died.insert(e);
            <span class="keywordtype">int</span> r = <a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a>(frontier, p, e.org, died);
            r +=    <a class="code" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">updateFrontier</a>(frontier, e.dest, p, died);

            <span class="comment">//assert (r == 0);</span>
            <span class="keywordflow">if</span> (!r)
            {
                vector&lt;Point&gt; triangle(3);
                triangle[0] = e.org;
                triangle[1] = e.dest;
                triangle[2] = p;
            <span class="comment">//cout &lt;&lt; &quot;    New triangle: &quot; &lt;&lt;p &lt;&lt; &quot;, &quot; &lt;&lt; e.org &lt;&lt; &quot;, &quot; &lt;&lt; e.dest &lt;&lt; endl;</span>
            triangles.push_back(triangle);
             }
        }
    }

    std::vector&lt;Edge&gt; newEdges(triangles.size() * 3);
    <span class="comment">//list&lt;Edge&gt; newEdges();</span>


    <span class="comment">//  cout &lt;&lt; &quot;Returning triangles\n&quot;;</span>
    <span class="keywordtype">int</span> j = 0;
    <span class="keywordflow">for</span> (list&lt;vector&lt;Point&gt; &gt;::const_iterator i = triangles.begin(); i != triangles.end(); i++)
    {
        <span class="comment">/*newEdges.push_back(Edge((*i)[0], (*i)[1]));</span>
<span class="comment">        newEdges.push_back(Edge((*i)[1], (*i)[2]));</span>
<span class="comment">        newEdges.push_back(Edge((*i)[2], (*i)[0]));*/</span>
        newEdges[j].org = (*i)[0];
        newEdges[j++].dest = (*i)[1];
        newEdges[j].org = (*i)[1];
        newEdges[j++].dest = (*i)[2];
        newEdges[j].org = (*i)[2];
        newEdges[j++].dest = (*i)[0];
    }

    cout &lt;&lt; <span class="stringliteral">&quot;Triangles:&quot;</span> &lt;&lt; triangles.size() &lt;&lt; <span class="stringliteral">&quot; Edges: &quot;</span> &lt;&lt; newEdges.size() &lt;&lt; <span class="stringliteral">&quot; Points: &quot;</span> &lt;&lt; points.size() &lt;&lt; endl;
    <span class="keywordflow">return</span> newEdges;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a2f04efebed6553f44cb40bf14febbeda_cgraph.svg" width="100%" height="304"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a87109ee46722d00232c89bb3bd713f79"></a><!-- doxytag: member="Triangulation::triangulate4" ref="a87109ee46722d00232c89bb3bd713f79" args="(const vector&lt; Point &gt; &amp;points, list&lt; Point &gt; &amp;centers, TriangulationBeginnings &amp;tb, const int maxDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt; <a class="el" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">Triangulation::triangulate4</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangulationBeginnings &amp;&#160;</td>
          <td class="paramname"><em>tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00440">440</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8cpp_source.html#l00239">findTriangleCenter()</a>, <a class="el" href="triangulation_8h_source.html#l00237">Triangulation::TriangulationBeginnings::hullEdges</a>, <a class="el" href="triangulation_8cpp_source.html#l00402">splitPoints()</a>, and <a class="el" href="triangulation_8h_source.html#l00338">TRIANGULATE</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00588">vertexHull()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespaceTriangulation.html#a8dfdfb7b59b3e760ba74b5e1ec5af3c9">ListOfLists</a> listOfLists;
  <span class="comment">//uint64_t microseconds;</span>
  <span class="comment">//PreciseTimer timer = PreciseTimer::currentTime();</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Using fast split algorithm\n&quot;</span>;

  <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints started-----\n&quot;;</span>
  <a class="code" href="namespaceTriangulation.html#a7ccdc1b0b225bde006f9e12fbcf0ab16">splitPoints</a>(points, tb, listOfLists, maxDistance);
  <span class="comment">//cerr &lt;&lt; &quot;-----splitPoints finished-----\n&quot;;</span>
  <span class="comment">//microseconds = timer.usecsTo(PreciseTimer::currentTime());</span>
  <span class="comment">//cerr &lt;&lt; &quot;splitPoints Real time: &quot; &lt;&lt; microseconds &lt;&lt; &quot; microseconds, &quot; &lt;&lt; microseconds/1000000.0 &lt;&lt; &quot; secs\n&quot;;</span>
    <span class="comment">//return vector&lt;Edge&gt;();</span>

    cout &lt;&lt; <span class="stringliteral">&quot;(triangulate4) Points: &quot;</span> &lt;&lt; points.size() &lt;&lt; endl;

    <span class="keywordtype">size_t</span> countOfEdges = 0;

    vector&lt;Edge&gt; *edges = <span class="keyword">new</span> vector&lt;Edge&gt; [listOfLists.size()];

    <span class="keywordtype">size_t</span> t = 0;
    <span class="keywordflow">for</span> (ListOfLists::const_iterator i = listOfLists.begin(); i != listOfLists.end(); i++, t++)
    {
    <span class="comment">//cout &lt;&lt; &quot;    size:&quot; &lt;&lt; i-&gt;mList.size() &lt;&lt; endl;</span>
        <span class="comment">//all += i-&gt;size();</span>

    vector&lt;Point&gt; newpoints(i-&gt;mList.size());
        <span class="keywordtype">int</span> k = 0;
    <span class="keywordflow">for</span> (<a class="code" href="namespaceTriangulation.html#aea0dc50942b8a3354ce53d192b202a1b">Lpci</a> j = i-&gt;mList.begin(); j != i-&gt;mList.end(); j++)
            newpoints[k++] = *j;

    edges[t] = <a class="code" href="triangulation_8h.html#a0f3136676982ac4ba38ce4bdbe54b69d">TRIANGULATE</a>(newpoints);
        <span class="comment">//edges[t] = vector&lt;Edge&gt;();</span>

        <span class="keywordflow">if</span> (edges[t].size() != 0)
            tb.hullEdges[t] = (int)countOfEdges;
        <span class="keywordflow">else</span>
            tb.hullEdges[t] = -1;

        countOfEdges += edges[t].size();
    }

    cout &lt;&lt; <span class="stringliteral">&quot;Total edges: &quot;</span> &lt;&lt; countOfEdges &lt;&lt; endl;

    vector&lt;Edge&gt; result(countOfEdges);

    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> l = 0, currentEdgesArray = 0, currentEdgesIndex = 0;
             currentEdgesArray &lt; listOfLists.size() &amp;&amp; l &lt; countOfEdges;
             currentEdgesIndex++)
    {
        <span class="keywordflow">if</span> (currentEdgesIndex &gt;= edges[currentEdgesArray].size())
        {
      <span class="comment">//cout &lt;&lt; &quot;!!! currentEdgesIndex:&quot; &lt;&lt; currentEdgesIndex &lt;&lt; &quot; currentEdgesArray:&quot; &lt;&lt; currentEdgesArray &lt;&lt; endl;</span>
            currentEdgesIndex = -1;
            currentEdgesArray++;
            <span class="keywordflow">continue</span>;
        }
        result[l++] = edges[currentEdgesArray][currentEdgesIndex];
    }

  <span class="keywordflow">for</span> (vector&lt;Edge&gt;::const_iterator it = result.begin(); it != result.end(); it += 3)
    centers.push_back(<a class="code" href="namespaceTriangulation.html#a80f248d30ab0a769a04a9bbbabc262bf">findTriangleCenter</a>(it-&gt;org, it-&gt;dest,
      (it+1)-&gt;dest == it-&gt;dest ? (it+1)-&gt;org : (it+1)-&gt;dest));

    <span class="keyword">delete</span> [] edges;


    <span class="keywordflow">return</span> result;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a87109ee46722d00232c89bb3bd713f79_cgraph.svg" width="100%" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab5d4d0b6773086cbf0228416e496b47d"></a><!-- doxytag: member="Triangulation::updateFrontier" ref="ab5d4d0b6773086cbf0228416e496b47d" args="(set&lt; Edge, EdgeCmp &gt; &amp;frontier, const Point &amp;a, const Point &amp;b, set&lt; Edge, EdgeCmp &gt; &amp;died)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceTriangulation.html#ab5d4d0b6773086cbf0228416e496b47d">Triangulation::updateFrontier</a> </td>
          <td>(</td>
          <td class="paramtype">set&lt; Edge, EdgeCmp &gt; &amp;&#160;</td>
          <td class="paramname"><em>frontier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; Edge, EdgeCmp &gt; &amp;&#160;</td>
          <td class="paramname"><em>died</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00203">203</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8cpp_source.html#l00033">Triangulation::Edge::flip()</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00521">triangulate()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">#if !defined(_MSC_VER) || (_MSC_VER &gt; 1500)         // TODO: VS2008 doesn&#39;t compile this code!?</span>
<span class="preprocessor"></span>    Edge e(a,b);
    <span class="keywordflow">if</span> (frontier.find(e) != frontier.end())
    {
        <span class="comment">//cout &lt;&lt; &quot;[updateFrontier] erasing &quot; &lt;&lt; e &lt;&lt; &quot;from frontier\n&quot;;</span>
        frontier.erase(e);
        died.insert(e);
    }
    <span class="keywordflow">else</span>
    {
        e.flip();
        <span class="keywordflow">if</span> (died.find(e) == died.end())
        {
            <span class="comment">//cout &lt;&lt; &quot;[updateFrontier] inserting &quot; &lt;&lt; e &lt;&lt; &quot; with length: &quot; &lt;&lt; e.org.remoteness(e.dest)&lt;&lt; &quot; to frontier\n&quot;;</span>
            frontier.insert(e);
        }
        <span class="keywordflow">else</span>
            <span class="keywordflow">return</span> 1;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_ab5d4d0b6773086cbf0228416e496b47d_cgraph.svg" width="430" height="40"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="afc6d99d4d3840905bf21f1feba1efd9b"></a><!-- doxytag: member="Triangulation::vertexHull" ref="afc6d99d4d3840905bf21f1feba1efd9b" args="(const vector&lt; Point &gt; &amp;points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt; <a class="el" href="namespaceTriangulation.html#afc6d99d4d3840905bf21f1feba1efd9b">Triangulation::vertexHull</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00588">588</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8cpp_source.html#l00440">triangulate4()</a>, and <a class="el" href="triangulation_8cpp_source.html#l00603">vertexHullFromTriangulation()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (points.size() &lt; 3)
    {
        cout &lt;&lt; <span class="stringliteral">&quot;No enought data!\n&quot;</span>;
        <span class="keywordflow">return</span> std::vector&lt;Edge&gt;();
    }

    list&lt;Point&gt; tmp;
    TriangulationBeginnings tb;

    std::vector&lt;Edge&gt; triangulations = <a class="code" href="namespaceTriangulation.html#a87109ee46722d00232c89bb3bd713f79">triangulate4</a>(points, tmp, tb);
    <span class="keywordflow">return</span> <a class="code" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">vertexHullFromTriangulation</a>(triangulations, (<span class="keywordtype">int</span>)points.size(), tb);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_afc6d99d4d3840905bf21f1feba1efd9b_cgraph.svg" width="100%" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a575d16383c40ca9fefa14b5abfa8fae2"></a><!-- doxytag: member="Triangulation::vertexHullFromTriangulation" ref="a575d16383c40ca9fefa14b5abfa8fae2" args="(const std::vector&lt; Edge &gt; &amp;edges, const int pointsCount, const TriangulationBeginnings &amp;tb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTriangulation_1_1Edge.html">Edge</a> &gt; <a class="el" href="namespaceTriangulation.html#a575d16383c40ca9fefa14b5abfa8fae2">Triangulation::vertexHullFromTriangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pointsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangulationBeginnings &amp;&#160;</td>
          <td class="paramname"><em>tb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8cpp_source.html#l00603">603</a> of file <a class="el" href="triangulation_8cpp_source.html">triangulation.cpp</a>.</p>

<p>References <a class="el" href="triangulation_8cpp_source.html#l00094">Triangulation::Edge::cosAngle()</a>, <a class="el" href="triangulation_8h_source.html#l00178">Triangulation::Edge::dest</a>, <a class="el" href="triangulation_8h_source.html#l00237">Triangulation::TriangulationBeginnings::hullEdges</a>, <a class="el" href="triangulation_8h_source.html#l00236">Triangulation::TriangulationBeginnings::numOfGroups</a>, and <a class="el" href="triangulation_8h_source.html#l00177">Triangulation::Edge::org</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00588">vertexHull()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i = 0;
    std::vector&lt;Edge&gt; result(pointsCount);
    multimap&lt;Point, Edge&gt; edgeList;
    multimap&lt;Point, Edge&gt;::const_iterator it;
    pair&lt;multimap&lt;Point, Edge&gt;::iterator, multimap&lt;Point, Edge&gt;::iterator&gt; ret;

    <span class="comment">// creating data structure in which it is easy to find the edges originating from a given point</span>
    <span class="keywordflow">for</span> (vector&lt;Edge&gt;::const_iterator i = edges.begin() + 1; i != edges.end(); i++)
        edgeList.insert(make_pair(i-&gt;org, *i));


    <span class="comment">//cout &lt;&lt; &quot;========================\n&quot;;</span>
    Point point0 = edges[0].org;
    <span class="comment">//cout &lt;&lt; &quot;Point0 :&quot; &lt;&lt; point0 &lt;&lt; &quot; Point1 :&quot; &lt;&lt; edges[0].dest &lt;&lt; endl;</span>


    Edge cur;
    <span class="keywordtype">bool</span> firstIteration = <span class="keyword">true</span>;
    <span class="keywordtype">int</span> groupCounter = -1;

    <span class="comment">//cout &lt;&lt; &quot;tb.numOfGroups: &quot; &lt;&lt; tb.numOfGroups &lt;&lt; endl;</span>

    <span class="keywordflow">while</span> (groupCounter &lt; tb.numOfGroups)
    {
        <span class="keywordflow">if</span> (cur.dest == point0 || firstIteration)
        {
            firstIteration = <span class="keyword">false</span>;
            groupCounter ++;

            <span class="keywordflow">if</span> (groupCounter == tb.numOfGroups)
                <span class="keywordflow">break</span>;

            <span class="keywordflow">if</span> (tb.hullEdges[groupCounter] == -1)
            {
                groupCounter++;
                <span class="keywordflow">continue</span>;
            }

            <span class="comment">//cout &lt;&lt; &quot;|||Next group : &quot; &lt;&lt; tb.hullEdges[groupCounter] &lt;&lt; endl;</span>
            cur.org = point0 = edges[tb.hullEdges[groupCounter]].org;
            cur.dest = edges[tb.hullEdges[groupCounter]].dest;
            result[i++] = cur;
            <span class="keywordflow">continue</span>;
        }

        <span class="comment">// searching all outgoing edges form the given point</span>
        ret = edgeList.equal_range(cur.dest);
        <span class="comment">//cout &lt;&lt; &quot;    &quot; &lt;&lt; cur.dest &lt;&lt; &quot;:::: \n&quot;;</span>
        <span class="keywordtype">double</span> maxAngle = -1.1;
        Edge maxEdge;
        <span class="keywordflow">for</span> (it = ret.first; it!=ret.second; ++it)
        {
            <span class="comment">//     cout &lt;&lt; &quot;        &quot; &lt;&lt; (*it).second &lt;&lt; endl;</span>
                 <span class="keywordtype">double</span> angle = cur.cosAngle((*it).second); <span class="comment">// cosinus</span>
                 <span class="keywordflow">if</span> (angle &gt; maxAngle)
                 {
                     maxAngle = angle;
                     maxEdge = (*it).second;
                 }
        }
        <span class="comment">//cout &lt;&lt; &quot;    maxAngle: &quot; &lt;&lt; maxAngle &lt;&lt; &quot; maxEdge: &quot; &lt;&lt; maxEdge &lt;&lt; endl;</span>
        cur = maxEdge;
        result[i++] = maxEdge;
    }

    <span class="keywordflow">return</span> result;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespaceTriangulation_a575d16383c40ca9fefa14b5abfa8fae2_cgraph.svg" width="100%" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a56b844197167a7e205b51af676782dc2"></a><!-- doxytag: member="Triangulation::DEFAULT_MAX_DISTANCE" ref="a56b844197167a7e205b51af676782dc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="namespaceTriangulation.html#a56b844197167a7e205b51af676782dc2">Triangulation::DEFAULT_MAX_DISTANCE</a> = 200.0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00042">42</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa0cc00702ac5ec0a1a149038e77e24f"></a><!-- doxytag: member="Triangulation::EPSILON" ref="afa0cc00702ac5ec0a1a149038e77e24f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double <a class="el" href="namespaceTriangulation.html#afa0cc00702ac5ec0a1a149038e77e24f">Triangulation::EPSILON</a> = 0.00001</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="triangulation_8h_source.html#l00043">43</a> of file <a class="el" href="triangulation_8h_source.html">triangulation.h</a>.</p>

<p>Referenced by <a class="el" href="triangulation_8cpp_source.html#l00065">doubleEqual()</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 23:44:59 for DeepView by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
